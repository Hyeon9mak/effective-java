# 아이템 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라

책에서 이야기하는 태그란 **해당 클래스가 어떠한 타입인지 정보를 갖고 있는 필드(멤버 변수)** 를 의미한다. 
태그를 이용하면 하나의 클래스로 두 가지 이상의 타입을 표현(정의)할 수 있다. 
태그 달리 클래스의 예시부터 살펴보자.

## 태그 달린 클래스 예시
```java
class Figure {
    enum Shape { RECTANGLE, CIRCLE };

    // 태그 필드 - 현재 모양을 나타낸다.
    final Shape shape;

    // 다음 필드들은 모양이 사각형(RECTANGLE)일 때만 쓰인다.
    double length;
    double width;

    // 다음 필드는 모양이 원(CIRCLE)일 때만 쓰인다.
    double radius;

    // 원용 생성자
    Figure(double radius) {
        shape = Shape.CIRCLE;
        this.radius = radius;
    }

    // 사각형용 생성자
    Figure(double length, double width) {
        shape = Shape.RECTANGLE;
        this.length = length;
        this.width = width;
    }

    double area() {
        switch(shape) {
            case RECTANGLE:
                return length * width;
            case CIRCLE:
                return Math.PI * (radius * radius);
            default:
                throw new AssertionError(shape);
        }
    }
}
```

위와 같은 형태의 클래스를 **태그 달린 클래스** 라고 명한다.  
태그 달린 클래스에는 수 많은 단점이 존재한다. 그저 장황하고 오류내기 쉽고 비효율적일 뿐이다.

<br>

## 태그 달린 클래스의 단점들
### 쓸데 없는 코드가 많다

---

- 태그에 대한 선언
- 각 태그에 따라 사용되거나 사용되지 않는 필드
- 태그에 따른 메서드의 행동분기(switch)

---

불필요한 코드가 많아지므로 가독성이 떨어진다. 게다가 필드를 `final`로 선언할 경우 
해당 태그에서 사용되지 않는 필드들도 생성자에서 초기화를 진행해야 한다.

<br>

### 오류 사항이 런타임에서나 발견된다

불변성을 지키기 위해 `final` 필드를 선언하고, 불필요한 필드까지 초기화를 진행한다고 가정하자. 
이 단계에서 컴파일러는 도움을 줄 수 없다. 엉뚱한 필드를 초기화 해도 런타임에서야 문제가 드러난다. 

<br>

### 태그를 추가하려면 코드를 수정해야 한다
새로운 태그를 추가할 때마다 모든 `switch`문을 찾아 새 태그를 처리하는 코드를 추가해야 하는데, 
하나라도 빠뜨리면 역시 런타임에서야 문제를 발견할 수 있다. 

<br>

### 인스턴스의 타입만으로 현재 태그를 유추할 수 없다
직접 메서드를 사용해보거나, 네이밍을 이용해야 타입을 유추할 수 있다.

<br>

## 클래스 계층구조로 바꾸는 방법