# 아이템62. 다른 타입이 적절하다면 문자열 사용을 피하라
## 🙅‍♂️ 문자열은 다른 값 타입을 대신하기에 적합하지 않다.
파일, 네트워크, 키보드 입력으로부터 데이터를 받을 때 주로 문자열을 사용하지만, 
입력된 데이터가 **진짜 문자열일 때만** 문자열을 사용하는게 좋다.  
  
받은 데이터가 수치형이라면 int, float, BigInteger 등 해당하는 수치형으로, 
'예/아니오' 질문의 답이라면 적절한 열거 타입이나 boolean으로 변환해야 한다.  
기본 타입이든 참조 타입이든 적잘한 타입이 있다면 그것을 사용하고, **없다면 새로 하나 만들어라.**  
어지간하면 문자열 사용을 피하라.

## 🙅‍♂️ 문자열은 열거 타입을 대신하기에 적합하지 않다.
우선 '열거 패턴'의 문제부터 짚어보자. (아이템 34)

```java
public static final int APPLE_FUJI          = 0;
public static final int APPLE_PIPPIN        = 1;
public static final int APPLE_GRANNY_SMITH  = 2;

public static final int ORANGE_NAVEL  = 0;
public static final int ORANGE_TEMPLE = 1;
public static final int ORANGE_BLOOD  = 2;
```
이와 같은 정수 열거 패턴에는 단점이 많다.

### 단점1. 타입 안전을 보장할 방법이 없으며, 표현력도 좋지 않다.
오렌지를 건네야 할 메서드에 사과를 보내도 값이 같으면 컴파일러는 경고를 출력하지 않는다.

```java
int i = (APPLE_FUJI - ORANGE_TEMPLE) / APPLE_PIPPIN;
// 오렌지 향의 사과 소스!
```

### 단점2. 이름공간을 지원하지 않아 접두어를 써서 충돌을 방지해야 한다.
자바가 열거 패턴을 위한 별도 이름공간(namespace)을 지원하지 않기 때문에 접두어를 써서 이름 충돌을 방지해야 한다.  

```
수은(원소) -> MERCURY -> ELEMENT_MERCURY
수성(행성) -> MERCURY -> PLANET_MERCURY
```

### 단점3. 프로그램이 깨지기 쉽다.
평범한 상수를 나열한 것뿐이라 컴파일하면 그 값이 클라이언트(API가 적용된 클래스: 코드, 프로그램) 파일에 그대로 새겨진다.  
즉, API의 상수 값이 바뀌면 클라이언트도 재컴파일을 해야만 한다.

### 단점4. 정수 상수는 문자열로 출력하기 까다롭다.
해당 값을 출력하거나 디버거로 살펴보면, 정수로서의 의미가 아닌 문자열 숫자로만 보여서 쓸모가 없다. 
같은 정수 열거 그룹에 속한 모든 상수를 한 바퀴 순회하는 방법도 마땅치 않으며, 상수가 총 몇 개인지 알 방법도 없다.

### 정수 열거 패턴이 이정도, 문자열 열거 패턴은 더 나쁘다.
상수의 의미를 출력할 수 있다는 점은 좋지만, 문자열 상수의 이름 대신 문자열 값을 그대로 하드코딩하게 만들기 때문이다.  
하드코딩한 문자열에 오타가 있어도 컴파일러는 확인할 길이 없으니, 자연스럽게 런타임에 버그가 생긴다. 문자열 비교에 따른 성능 저하는 덤이다.

### 열거 패턴은 열거 타입으로 해결하자.
```java
public enum Apple { FUJI, PIPPIN, GRANNY_SMITH }
public enum Orange { NAVEL, TEMPLE, BLOOD }
```
앞선 문제들이 모두 말끔히 해결된다.

## 🙅‍♂️ 문자열은 혼합 타입을 대신하기에 적합하지 않다.
```java
String compoundKey = className + "#" + i.next();
```

*className*과 *i.next()* 요소 사이에 *"#"*를 추가해서 서로 다른 타입의 두 요소간 구분을 시도한 케이스다. 
혹여라도 두 요소를 구분해주는 문자 #이 둘 중 하나에라도 쓰인다면 혼란스러운 결과를 초래한다.  
  
두 곳 모두에 안쓰인다는 걸 보장하더라도, 각 요소를 분리해서 사용하려면 
문자열을 파싱해야 하므로 *느리고, 귀찮고, 오류 가능성도 커진다*.  
  
또한 적절하게 equals, toString, compareTo 같은 메서드를 사용할 수도 없으며, 
String 클래스가 제공하는 메서드에만 의존해야 한다.  
차라리 두 요소를 병합해서 관리하는 클래스를 새로 만드는 편이 낫다.  
이런 클래스는 보통 private 정적 멤버 클래스로 선언한다.

```java

예시 천천히 찾아볼 것.
public class effectiveJavaStudy {
    private String className;
    private Iterator i;

    private static class compoundKey {
        private String className;
        private Iterator i;

        private Builder(String className, Iterator i){
            this.className = className;
            this.i = i;
        }
    }
}
```

## 🙅‍♂️ 문자열은 권한(capacity)을 표현하기에 적합하지 않다.
